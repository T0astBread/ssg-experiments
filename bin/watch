#!/usr/bin/env node

// Copied and adapted from https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#writing-an-incremental-program-watcher

const cp = require("node:child_process")
const ts = require("typescript")

const COMPILE_TIMER_LABEL = "Compiling build script took"
const LOG_PREFIX = "[watch-build]"
const WANT_OUTPUT = ["1", "true"].includes(
	process.env.WATCH_BUILD_OUTPUT
)

/** @type Map<string, Function> */
const signalListeners = new Map()

let hasDiagnostics = false
/** @type string | undefined */
let killedBy = undefined
/** @type cp.ChildProcess | undefined */
let nodeProcess = undefined
let watcher = undefined
/** @type Function | undefined */
let watcherPromiseResolve = undefined
let watcherPromise = new Promise(r => {
	watcherPromiseResolve = r
})

function error(...args) {
	console.error(LOG_PREFIX, ...args)
}

function info(...args) {
	if (WANT_OUTPUT) console.info(LOG_PREFIX, ...args)
}

function time(label) {
	if (WANT_OUTPUT) console.time(`${LOG_PREFIX} ${label}`)
}

function timeEnd(label) {
	if (WANT_OUTPUT) console.timeEnd(`${LOG_PREFIX} ${label}`)
}

function stopWatching() {
	if (watcher) {
		watcher.close()
	}
	if (watcherPromiseResolve) {
		watcherPromiseResolve()
	}
}

/** @type ts.FormatDiagnosticsHost */
const formatHost = {
	getCanonicalFileName: path => path,
	getCurrentDirectory: ts.sys.getCurrentDirectory,
	getNewLine: () => ts.sys.newLine,
}

function watchMain() {
	const entrySrc = `${process.cwd()}/build/index.ts`
	const entryCompiled = `${process.cwd()}/_build/index.js`

	const configPath = ts.findConfigFile(
		process.cwd(),
		ts.sys.fileExists,
		"tsconfig.json"
	)
	if (!configPath) {
		throw new Error("Could not find a valid 'tsconfig.json'.")
	}

	// TypeScript can use several different program creation "strategies":
	//  * ts.createEmitAndSemanticDiagnosticsBuilderProgram,
	//  * ts.createSemanticDiagnosticsBuilderProgram
	//  * ts.createAbstractBuilder
	// The first two produce "builder programs". These use an incremental strategy
	// to only re-check and emit files whose contents may have changed, or whose
	// dependencies may have changes which may impact change the result of prior
	// type-check and emit.
	// The last uses an ordinary program which does a full type check after every
	// change.
	// Between `createEmitAndSemanticDiagnosticsBuilderProgram` and
	// `createSemanticDiagnosticsBuilderProgram`, the only difference is emit.
	// For pure type-checking scenarios, or when another tool/process handles emit,
	// using `createSemanticDiagnosticsBuilderProgram` may be more desirable.
	const createProgram = ts.createSemanticDiagnosticsBuilderProgram

	// Note that there is another overload for `createWatchCompilerHost` that takes
	// a set of root files.
	const host = ts.createWatchCompilerHost(
		configPath,
		{
			outDir: `${process.cwd()}/_build`,
		},
		ts.sys,
		createProgram,
		reportDiagnostic,
		reportWatchStatusChanged
	)

	// You can technically override any given hook on the host, though you probably
	// don't need to.
	// Note that we're assuming `origCreateProgram` and `origPostProgramCreate`
	// doesn't use `this` at all.
	const origCreateProgram = host.createProgram
	host.createProgram = (_rootNames, options, host, oldProgram) => {
		time(COMPILE_TIMER_LABEL)
		hasDiagnostics = false
		return origCreateProgram([entrySrc], options, host, oldProgram)
	}
	const origPostProgramCreate = host.afterProgramCreate

	host.afterProgramCreate = program => {
		timeEnd(COMPILE_TIMER_LABEL)
		origPostProgramCreate(program)

		if (nodeProcess) {
			nodeProcess.kill()
		}
		if (!hasDiagnostics) {
			nodeProcess = cp.spawn("node", [entryCompiled], {
				stdio: "inherit",
			})
		}
	}

	// `createWatchProgram` creates an initial program, watches files, and updates
	// the program over time.
	watcher = ts.createWatchProgram(host)
}

function reportDiagnostic(diagnostic) {
	hasDiagnostics = true
	error(
		"Error",
		diagnostic.code,
		":",
		ts.flattenDiagnosticMessageText(
			diagnostic.messageText,
			formatHost.getNewLine()
		)
	)
}

/**
 * Prints a diagnostic every time the watch status changes.
 * This is mainly for messages like "Starting compilation" or "Compilation completed".
 */
function reportWatchStatusChanged(diagnostic) {
	info(ts.formatDiagnostic(diagnostic, formatHost).trim())
}

// Forward signals to child process.
// NOTE: The list of signals is incomplete.
;["SIGINT", "SIGTERM"].forEach(signal => {
	const listener = () => {
		killedBy = signal
		if (nodeProcess) {
			nodeProcess.kill(signal)
		}
	}
	signalListeners.set(signal, listener)
	process.on(signal, listener)
})

process.on("SIGINT", stopWatching)
process.on("SIGTERM", stopWatching)

watchMain()

watcherPromise.finally(() => {
	// If we exited by signal, uninstall our signal handler and kill this
	// process with the signal that killed the child. That way, we
	// forward the signal to the parent process (e.g. a shell) correctly.
	if (nodeProcess) {
		console.log("nope")
		nodeProcess.once("exit", () => {
			if (killedBy) {
				signalListeners.forEach((v, k) => {
					process.removeListener(k, v)
				})
				process.kill(process.pid, killedBy)
			} else {
				process.exit(nodeProcess.exitCode)
			}
		})
	}
})
